real-world-medium

14:32 30 May 2021

abbynie

* adenga

1. 训练利用ddd分析出合理业务需求和商业逻辑

2. 训练ddd实现微服务的拆分

3. 训练ddd分析领域层实体

4. 训练应用场景设计和测试驱动开发

* 领域层逻辑
  
  用户登录-----------》用户子域

  作者打草稿

  作者发布草稿--------》文章子域
  
  通知读者关注的作者有新作品
    
  读者阅读博客

  读者评论博客

  读者收藏博客以便后续浏览

  读者给博客点赞
   
  记录读者近期浏览的博客以便后期查找
 
  读者关注作者，当作者有新作品时通知读者

* 子域拆分
   
    支持子域：
     
    1. 用户子域
    
    核心子域

    1. 评论

    2. 文章子

    一般子域

    1. 消息通知

    2. token子域

* 领域词条

1. 用户

2. 读者----》用户

3. 作者----》用户

4. 文章

5. 评论

* usecases

领域场景

1. web 端

** 用户打草稿用例

1. 用例逻辑

    用户写文章----》 用户发布文章----》用户发布文章

    用户查看草稿列表------》用户编辑草稿-----》用户发布文章

2. 草稿与文章的区分

   1. 草稿的使用场景

      1. 用户写文章

      2. 用户查看草稿列表-----》用户编辑草稿

   2. 文章的使用场景

      1. 作者查看自己的创作已发布文章-----》点击文章查看详情

      2. 用户分页查看已发布文章-----》点击文章查看详情

3. 设计的目的

   1. 区分已发布文章和未发布文章

4. 设计草稿与文章：使用 status 来区分草稿与文章

5. 用例接口
   
   Write: the user writes an article
   
   EditDraftArticle:the user edits a draft article 

   Publish: the user publishes a draft article

   ViewDraftArticles: the author views draft articles
   
   View: the user view an article
   
** 用户修改已发布文章

1. 用例逻辑

    用户查看已发布文章---》用户编辑已发布文章----》用户重新发布文章

2. 设计目的

   1. 用户发布文章后可以进行二次创作，且不影响读者查看已完成内容

   2. 作者二次创作的内容只有作者创作完成发布后读者才能查看

3. 设计

   1. 用户编辑的已发布文章保存到一个副本储存区域中，每次修改都是修改这个副本

   2. 用户发布修改，更新副本内容到文章中

4. 用例接口
   
   ViewPublicArticle:用户查看自己的发布的文章

   EditPublicArticle:系统保存已发布文章为草稿

   Republish:用户更新已发布文章

** 用户查看文章详情

用户查看文章列表---》用户查看文章详情

1. 用例场景描述

   1.用户查看文章列表--------》点击文章查看详情

2. 设计的目的

   1. 用户查看文章列表，点击文章查看详情,用户如何获取文章详情

3. 用例的设计

   设计一：

   1. 在用户查看了文章列表后，要查看文章详情时通过文章标题查找到文章

      1. 找到的文章可能重复，这并不是搜索文章，如果搜索文章可能存在多篇满足条件的文章

   设计二：

   1. 设计一个 ID 到文章属性中，每篇文章都有一个唯一的 ID，查找文章详情通过 ID 找到唯一的文章

   2. 生成方式：设计一个序列发生器生成 ID

      ```
      interface IDGenerator {
        //生成数字类型的ID
        NumberID() int
      }
      ```

4. 用例测试

   1. 每篇文章 ID 保证是在所有文章全家唯一的

** 文章自动保存

1.用例场景

1. 由于存在突然断电、系统崩溃、作者忘记点击保存按钮就关闭页面等情况，导致作者创作，编辑的内容丢失，造成不好的体验

2. 设计目的

   1. 减少意外损失，防止意外

   2. 让作者更专注内容创作

3. 用例描述

   1. 用户编辑文章，系统自动保存文章内容到一个安全的地方

4. 设计

   1. 用户如何自动保存文章内容

      1. 定时保存

      2. 实时保存

   2. 用户保存文章到哪里

      1. 本地

      2. 远程

5. 用例设计

   1. 用户编辑文章时，系统实时保存文章到本地

   2. 系统定时同步内容到远程

   3. 当系统启动时同步一次内容到远程

** TODO

1. 客户端实现当服务器出现问题时缓存到本地和网络恢复时自动同步功能

2. ID 序列发生器实现

## 用户注册、登录、退出登录

用户注册---》用户登录系统-----》用户退出登录

1. 场景描述

   1. 用户创作文章知道创作者，用户可以在多端（手机端、网站）查看和编辑创作的文章

   2. 用户发布文章时鉴权

2. 设计的目的

   1. 在用户创作文章、发布文章知道是谁在操作和用户是否有权限

** 用户注册

1. 场景描述

   1. 用户创作、编辑文章和查看个人创作文章列表，系统都需要知道用户是谁

2. 设计的目的

   1. 为了避免用户每次操作都输入个人信息，让用户先在系统中注册个人信息

3. 用例设计

   1. 用户输入用户名、邮箱、密码注册成功

   2. 用户输入的邮箱已注册过，注册失败

### 用户登录

1. 用例场景

   用户在系统中输入用户名、密码登录系统,登录成功返回登录凭证客户端保存

2. 用例设计目的

   1. 用户编辑、发布文章的时候需要鉴权

   2. 用户在系统中创作文章时需要知道作者

3. 设计

   1. 用例一：用户名密码登录

   2. 用例二：手机快捷登录

   3. 用例三：Facebook、微信、QQ 等第三方授权登录

#### 用户名密码登录

1. 用例描述

用户输入用户名、密码登录，系统校验用户名、密码正确，登录成功返回登录凭证

2. 用例交互

```
//user login by user name and password
User                                         系统
---------------1 username and password ------->login(){
                                                    verifyUserAndPassword()
                                                     token := generateToken()
                                                     return token
                                                  }

<--------------2 token success-----------------------

```

```
思考：像QQ用户在QQ注册之后，能在微信登录，但是QQ中注册时的用户信息修改并不会影响微信中的用户信息发生变化，所以登录注册与用户信息维护是否需要分离?用户信息
是与应用相关，但是登录账号是各个平台可以共享,应当将账号密码管理抽取为公共子域
```

#### 用户快捷登录

用户输入手机号-------》系统生成手机验证码--------------》系统发送验证码到用户手机号----------》用户输入验证码----------》系统校验验证码--------》用户登录

1. 用例描述

```

// user mobile login
   O
  /|\ -------(API)-----------> 系统 ( high order function , lambda )
   /\                                  高阶函数在哪一层组合????
User                            系统
-------1 mobile number-------> getMobileVerifyCodeForLogin(){
        GetUserByPhone();
        GenerateMobileVerifyCode();
        SaveVerifyCode();
        return verifyCode}  GenerateMobileVerifyCode()
<------2 verify code(gsm)----- sendVerifyCode
-------3 verify code---------> login(){
                                  if(verify()) {
                                    tokenSuccess, err := getTokenSuccess();   // token sub domain (session sub
                                    domain)
                                    return tokenSuccess;
                                  }
                                  return failed
                               }
<------4 token success--------
```

```
login()  -----------> * rpc */ login()

login()  ---> login() --> base functions { sub domain }
```

2. 设计目的

   1. 方便用户通过手机号快捷登录

3. 用例

   1. 系统生成手机验证码

      1. 由生成验证码服务生成手机验证码

      ```
      struct VerifyCode {

      }
      generate()
      verify()
      ```

   2. 发送验证码给用户

   3. 抽取发送手机信息子域

      type MessageInfo struct{
      iphone string
      messag string
      }

      ```
        type SendMessagService interface {
          Send(message MessageInfo)
        }
      ```

4. 校验验证码

5. 用户登录

### TODO

1. 用户快捷登录

2. 第三方授权登录

3. 多端同步登录

4. 验证码生成公共子服务

5. 短信消息发送公共子服务

6. 邮箱消息发送公共子服务

7. 平台账号密码子域

### 用户注册时邮箱校验

1. 用例描述

   1. 用户输入邮箱---》用户点击生成验证码-----》系统向用户邮箱发送验证码-----》用户查看邮箱输入验证码------》系统校验验证码是否正确

2. 设计目的

   1. 防止用户输错成别人邮箱注册系统导致后续无法接收通知和别人无法使用该邮箱注册系统

3. 用例

   1. 系统生成验证码(考虑验证生成拆分出验证码通用子领域)

      1. 抽取生成验证码为公共子域

      ```
         type VerificationCode{
              code string
         }
         //验证码校验接口
         type VerificationCodChecker interface {
              IfIsCorrect() //判断验证码是否正确
         }
         interface VerificationCodeGeneratorService{
            Generate() //生成验证码
         }
      ```

   2. 系统发送验证码到邮箱(邮箱服务子领域)

      1. 抽取邮箱服务公共子域

      ```
        type EmailSenderService interface {
            Send() //发送邮件
        }
      ```

   3. 校验邮箱验证码是否正确

      1. 添加验证码校验接口到验证码生成服务公共子领域

### 用户更换邮箱时邮箱校验

1. 用例描述

   1. 用户点击校验邮箱-----》发送验证码到邮箱------》校验邮箱验证码是否正确

2. 设计目的

   1. 防止更换邮箱时输错邮箱，导致读者联系不了作者

3. 用例

   1. 系统生成用户邮箱验证码

   2. 系统发送验证码到邮箱

   3. 系统校验用户验证码是否正确

### 校验用户是否登录

1. 用例描述

   1. 客户端发送登录凭证，服务端校验是否登录

2. 设计目的

   1. 由于 http 的无状态，校验用户的登录状态

   2. 鉴权用户身份

3. 用例设计

```
  User                  System
  --------- 1 token-------> IsLoggedIn()
  ----------2 isLogin-----

```

    1. 登录凭证有效，用户已登录

    2. 登录凭证无效，用户未登录

### 用户退出登录

1. 用例描述

   1. 用户点击退出登录按钮退出登录状态

2. 设计目的

   1. 保证自己账户的安全

      1. 用户可能在公共场所登录

3. 用例设计

   1. 用户退出登录，清空登录状态记录

## 用户评论文章用例

用户评论文章-----》用户查看文章评论--------》用户回复评论------》用户删除评论

1. 用例描述

   1. 用户在文章下面发表评论-----》其他用户查看文章评论------》其他用户选择想要回复的评论回复

2. 设计目的

   1. 方便用户针对文章疑问与作者交流

3. 用例设计

   1. 用户评论文章

   2. 用户查看文章评论列表

   3. 用户回复评论

   4. 用户删除评论

### 文章作者删除评论

1. 用例描述

   文章作者删除用户评论

2. 设计目的

   1. 保持文章下面评论的干净，友善

3. 用例设计

   1. 删除评论

```
User                        system

-------1 articleID,commentID --------> DropComment(){
                                          err := DropByCreate()
                                          if errNoPermisssion{
                                             art := article.ViewArticle(article)
                                              if IsAuthor(){
                                                DropComment(articleID)
                                              }
                                          }
                                      }
<-------2 success---------------------
```

### TODO 业务需求思考

1. 如何让用户更快速的定位到自己喜欢看的文章

